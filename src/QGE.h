class QGE : public Exact_LU_Alg
{
	public:
		
		//Iterative L and U matrices for ERA updates
		mpq_t **Lq, **Uq;
		
		//Default Constructor
		QGE ();

		//User-specified constructor
		QGE (cmdOpt &);

		//Matrix file constructor
		QGE (string f_name);

		/*-----------------------------------------------------------------------------------------
		                        FUNCTIONS
		-----------------------------------------------------------------------------------------*/

		void set_RHS(double density_);

		
		//Doolittle Q_LU algorithm with no permutations (i.e., does not account for possibility of ZERO-valued pivots)
		void QD_LU_noPivoting(bool printIt);

		//Crout's Q_LU algorithm with no permutations (i.e., does not account for possibility of ZERO-valued pivots)
		void QC_LU_noPivoting(bool printIt);

		//Reduced matrix QGE Doolittle pivot (i.e., does not affect previous pivot rows/cols)
		void piv_red();

		//Reduced matrix QGE Crout pivot (i.e., does not affect previous pivot rows/cols)
		void piv_Crout_red();

		//Reduced matrix QGE pivot for LU updating; receives current L-matrix and U-tilde matrix
		void piv_red(mpq_t **L_mat, mpq_t **Ut_mat);

		//This algorithm can be used with the Doolittle and Crout ERA LU factorizations. 
		//All that is needed is to identify if the working L matrix is unit triangular. 
		//For Doolittle, the L matrix is unit triangular
		void FSub(bool unitTriang);

		//Same as above but the matrix to be forwarded is provided as an argument
		void FSub(mpq_t **mpq_mat, int mat_cols, bool unitTriang);
		
		//This algorithm can be used with the Doolittle and Crout ERA LU factorizations. 
		//All that is needed is to identify if the working U matrix is unit triangular. 
		//For Crouts, the U matrix is unit triangular
		void BSub(bool unitTriang);

		//Bartels-Golub LU update -- execute after an initial factorization has been calculated
		//Split QGE into separate L and U matrices -- execute after an initial factorization has been calculated
		void LU_Split();

		//Bartels Golub update
		void BG_Update();

};

QGE::QGE () {
	Exact_LU_Alg();
}

QGE::QGE (cmdOpt &run) {
	load_from_cmdOpt(run);
	
	Aq =  GFq_mat_init_density(rows, cols, get_lb(), get_ub(), get_seed1(), get_seed2(), get_density(), true);
}


void QGE::QD_LU_noPivoting(bool printIt)
{
	if(printIt)
		GFq_idx_formPrint(Aq, row_idx, col_idx, pSpace, 0);
		
	for(int i=1; i < rows; i++)
	{
		piv_red();
		if(printIt)
			GFq_idx_formPrint(Aq, row_idx, col_idx, pSpace, i);
	}
}

void QGE::QC_LU_noPivoting(bool printIt)
{
	if(printIt)
		GFq_idx_formPrint(Aq, row_idx, col_idx, pSpace, 0);
		
	for(int i=0; i < rows; i++)
	{
		piv_Crout_red();
		if(printIt)
			GFq_idx_formPrint(Aq, row_idx, col_idx, pSpace, i);
	}
}

void QGE::piv_red()
{
	mpq_t l_i, prod;
	mpq_inits(l_i, prod, NULL); 

	for(int i=stepNum+1; i < rows; i++)
	{
		mpq_div(l_i, Aq[row_idx[i]][col_idx[stepNum]], Aq[row_idx[stepNum]][col_idx[stepNum]]);

		for(int j=stepNum+1; j < cols; j++)
		{
			col_idx[j] = col_idx[j];
			mpq_mul(prod, l_i, Aq[row_idx[stepNum]][col_idx[j]]);
			mpq_sub(Aq[row_idx[i]][col_idx[j]], Aq[row_idx[i]][col_idx[j]], prod);						
		}
		mpq_set(Aq[row_idx[i]][col_idx[stepNum]], l_i);
	}
	stepNum++;
}

void QGE::piv_red(mpq_t **L_mat, mpq_t **Ut_mat)
{
	int i_stop;

	mpq_t prod;
	mpq_init(prod);

	//Lower triangular entries being generated by this update
	int l_col_size = num_ent;

	if (rows - stepNum - 1 < num_ent)
		l_col_size = rows - stepNum - 1;

	mpq_t *l = new mpq_t[l_col_size];

	for (int i = 0; i < l_col_size; i++)
		mpq_init(l[i]);

	i_stop = stepNum + num_ent + 1;

	if (i_stop > rows)
		i_stop = rows;

	//This first for-loop calculates the updated upper-triangular matrix
	for (int i = stepNum + 1; i < i_stop; i++)
	{
		mpq_div(l[i - stepNum - 1], Ut_mat[up_row_idx[i]][up_col_idx[stepNum]], Ut_mat[up_row_idx[stepNum]][up_col_idx[stepNum]]);

		for (int j = stepNum + 1; j < cols; j++)
		{
			mpq_mul(prod, l[i - stepNum - 1], Ut_mat[up_row_idx[stepNum]][up_col_idx[j]]);
			mpq_sub(Ut_mat[up_row_idx[i]][up_col_idx[j]], Ut_mat[up_row_idx[i]][up_col_idx[j]], prod);			
		}
	}

	//This second for-loop calculates the updated lower-triangular matrix
	for (int i = stepNum + 1; i < rows; i++)
	{
		for (int j = 0; j < l_col_size; j++)
		{
			mpq_mul(prod, L_mat[row_idx[i]][col_idx[stepNum + 1 + j]], l[j]);
			mpq_add(L_mat[row_idx[i]][col_idx[stepNum]], L_mat[row_idx[i]][col_idx[stepNum]], prod);
		}
	}
	stepNum++;
}

void QGE::piv_Crout_red()
{
	mpq_t sum, prod, diff;
	mpq_inits(sum, diff, prod, NULL);
						
	for (int i = stepNum; i < rows; i++) 
	{
		mpq_set_z(sum, mpz_ZERO);
					
		for (int k = 0; k < stepNum; k++) 
		{
			mpq_mul(prod, Aq[row_idx[i]][col_idx[k]], Aq[row_idx[k]][col_idx[stepNum]]);
			mpq_add(sum, sum, prod);
		}
		mpq_sub(Aq[row_idx[i]][col_idx[stepNum]], Aq[row_idx[i]][col_idx[stepNum]], sum);
	}

	for (int i = stepNum; i < rows; i++) 
	{
		mpq_set_z(sum, mpz_ZERO);

		for(int k = 0; k < stepNum; k++) 
		{
			mpq_mul(prod, Aq[row_idx[stepNum]][col_idx[k]], Aq[row_idx[k]][col_idx[i]]);
			mpq_add(sum, sum, prod);
		}
		
		if(i != stepNum)
		{
			mpq_sub(Aq[row_idx[stepNum]][col_idx[i]], Aq[row_idx[stepNum]][col_idx[i]], sum);
			mpq_div(Aq[row_idx[stepNum]][col_idx[i]], Aq[row_idx[stepNum]][col_idx[i]], Aq[row_idx[stepNum]][col_idx[stepNum]]);
		}
	}
	stepNum++;
}

void QGE::FSub(bool unitTriang)
{
	mpq_t prod;
	mpq_init(prod);
			
	//Initalize y-vector(s) to all 0s
	Yq = GFq_mat_init_zeros(rows, cols_B);
	
	for (int k = 0; k < cols_B; k++)
	{
		for (int i = 0; i < rows; i++)
		{					
			mpq_set(Yq[row_idx[i]][k], Bq[row_idx[i]][k]);
					
			for(int j = 0; j < i; j++)
			{
				mpq_mul(prod,  Aq[row_idx[i]][col_idx[j]], Yq[row_idx[j]][k]);
				mpq_sub(Yq[row_idx[i]][k], Yq[row_idx[i]][k], prod);
			}
			if(!unitTriang)
				mpq_div(Yq[row_idx[i]][k], Yq[row_idx[i]][k], Aq[row_idx[i]][col_idx[i]]);
		}
	}
}

void QGE::FSub(mpq_t **mpq_mat,int mat_cols, bool unitTriang)
{
	mpq_t prod;
	mpq_init(prod);

	for (int k = 0; k < mat_cols; k++)
	{
		for (int i = 0; i < rows; i++)
		{
			for (int j = 0; j < i; j++)
			{
				mpq_mul(prod, Aq[row_idx[i]][col_idx[j]], mpq_mat[row_idx[j]][k]);
				mpq_sub(mpq_mat[row_idx[i]][k], mpq_mat[row_idx[i]][k], prod);
			}
			if (!unitTriang)
				mpq_div(mpq_mat[row_idx[i]][k], mpq_mat[row_idx[i]][k], Aq[row_idx[i]][col_idx[i]]);
		}
	}
}


void QGE::BSub(bool unitTriang)
{
	mpq_t prod;
	mpq_init(prod);
			
	//Initalize Xq-vector(s) to all 0s
	Xq = GFq_mat_init_zeros(rows, cols_B);
				
	for (int k = 0; k < cols_B; k++)
	{
		for (int i = rows-1; i >= 0; i--)
		{
			mpq_set(Xq[row_idx[i]][k], Yq[row_idx[i]][k]);
		
			for(int j = i+1; j < rows; j++)
			{
				mpq_mul(prod,  Aq[row_idx[i]][col_idx[j]], Xq[row_idx[j]][k]);
				mpq_sub(Xq[row_idx[i]][k], Xq[row_idx[i]][k], prod);
			}
			if(!unitTriang)
				mpq_div(Xq[row_idx[i]][k], Xq[row_idx[i]][k], Aq[row_idx[i]][col_idx[i]]);	
		}
	}
}

void QGE::set_RHS(double density_)
{
	//Initialize elements in B to 0
	Bq = GFq_mat_init_density(rows, cols_B, get_lb(), get_ub(), get_seed1()*3, get_seed2()*2, density_, false);	
}

void QGE::LU_Split()
{
	Lq = GFq_mat_init_zeros(rows, cols);
	Uq = GFq_mat_init_zeros(rows, cols);
	
	for (int i = 0; i < rows; i++)
	{
		mpq_set_ui(Lq[i][i], 1, 1);
		for (int j = 0; j < i; j++)
			mpq_set(Lq[row_idx[i]][col_idx[j]], Aq[row_idx[i]][col_idx[j]]);
	
		for (int j = i; j < rows; j++)
			mpq_set(Uq[row_idx[i]][col_idx[j]], Aq[row_idx[i]][col_idx[j]]);
	}
}

void QGE::BG_Update()
{
	//Perform Bartels Golub permutation to prepare matrix for updating
	BG_Perm();

	Aq_plus = GFq_mat_init_density(rows, num_ent, get_lb(), get_ub(), get_seed1() - get_seed2() * 5, 4 * get_seed1() + get_seed2(), get_density(), false);

	FSub(Aq_plus, num_ent, true);

	GFq_mat_insert_cols(cols-num_ent, Uq, Aq_plus, up_col_idx, rows, num_ent);

	stepNum = ex_idx;

	for (int i = ex_idx; i < rows-1; i++)
		piv_red(Lq, Uq);

	//Merge the updated L and U matrices together
	for (int i = 0; i < rows; i++)
	{
		for (int j = 0; j < i; j++)
			mpq_set(Uq[up_row_idx[i]][up_col_idx[j]], Lq[row_idx[i]][col_idx[j]]);
	}
}

